// tests/unit/codegen_tests.rs

use razen_lang::backend::cranelift::{CodeGenerator, JITCompiler};
use razen_lang::backend::ir::{IRModule, IRFunction, Instruction, Operand};
use std::collections::HashMap;

#[cfg(test)]
mod code_generator_tests {
    use super::*;

    fn create_simple_ir_module() -> IRModule {
        let mut module = IRModule::new();
        
        let function = IRFunction {
            name: "test_func".to_string(),
            params: vec![],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Return {
                    value: Some(Operand::Constant(42)),
                },
            ],
            blocks: vec![],
        };
        
        module.functions.push(function);
        module
    }

    fn create_arithmetic_ir_module() -> IRModule {
        let mut module = IRModule::new();
        
        let function = IRFunction {
            name: "add_func".to_string(),
            params: vec![],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Add {
                    dest: "result".to_string(),
                    left: Operand::Constant(5),
                    right: Operand::Constant(3),
                },
                Instruction::Return {
                    value: Some(Operand::Register("result".to_string())),
                },
            ],
            blocks: vec![],
        };
        
        module.functions.push(function);
        module
    }

    #[test]
    fn test_code_generator_creation() {
        let result = CodeGenerator::new();
        assert!(result.is_ok(), "CodeGenerator should be created successfully");
    }

    #[test]
    fn test_simple_function_compilation() {
        let mut code_generator = CodeGenerator::new().expect("Failed to create CodeGenerator");
        let ir_module = create_simple_ir_module();
        
        let result = code_generator.generate(ir_module);
        assert!(result.is_ok(), "Simple function compilation should succeed");
        
        let compiled_program = result.unwrap();
        assert!(!compiled_program.bytecode.is_empty(), "Generated bytecode should not be empty");
    }

    #[test]
    fn test_arithmetic_function_compilation() {
        let mut code_generator = CodeGenerator::new().expect("Failed to create CodeGenerator");
        let ir_module = create_arithmetic_ir_module();
        
        let result = code_generator.generate(ir_module);
        assert!(result.is_ok(), "Arithmetic function compilation should succeed");
        
        let compiled_program = result.unwrap();
        assert!(!compiled_program.bytecode.is_empty(), "Generated bytecode should not be empty");
        assert!(compiled_program.bytecode.len() > 50, "Generated bytecode should be substantial");
    }

    #[test]
    fn test_function_with_parameters() {
        let mut code_generator = CodeGenerator::new().expect("Failed to create CodeGenerator");
        let mut module = IRModule::new();
        
        let function = IRFunction {
            name: "param_func".to_string(),
            params: vec!["int".to_string(), "int".to_string()],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Add {
                    dest: "result".to_string(),
                    left: Operand::Register("param0".to_string()), // First parameter
                    right: Operand::Register("param1".to_string()), // Second parameter
                },
                Instruction::Return {
                    value: Some(Operand::Register("result".to_string())),
                },
            ],
            blocks: vec![],
        };
        
        module.functions.push(function);
        
        let result = code_generator.generate(module);
        assert!(result.is_ok(), "Function with parameters should compile successfully");
    }

    #[test]
    fn test_multiple_functions_compilation() {
        let mut code_generator = CodeGenerator::new().expect("Failed to create CodeGenerator");
        let mut module = IRModule::new();
        
        // First function
        let func1 = IRFunction {
            name: "func1".to_string(),
            params: vec![],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Return {
                    value: Some(Operand::Constant(10)),
                },
            ],
            blocks: vec![],
        };
        
        // Second function
        let func2 = IRFunction {
            name: "func2".to_string(),
            params: vec![],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Return {
                    value: Some(Operand::Constant(20)),
                },
            ],
            blocks: vec![],
        };
        
        module.functions.push(func1);
        module.functions.push(func2);
        
        let result = code_generator.generate(module);
        assert!(result.is_ok(), "Multiple functions should compile successfully");
    }

    #[test]
    fn test_function_call_compilation() {
        let mut code_generator = CodeGenerator::new().expect("Failed to create CodeGenerator");
        let mut module = IRModule::new();
        
        // Callee function
        let callee = IRFunction {
            name: "callee".to_string(),
            params: vec![],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Return {
                    value: Some(Operand::Constant(42)),
                },
            ],
            blocks: vec![],
        };
        
        // Caller function
        let caller = IRFunction {
            name: "caller".to_string(),
            params: vec![],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Call {
                    dest: Some("result".to_string()),
                    function: "callee".to_string(),
                    args: vec![],
                },
                Instruction::Return {
                    value: Some(Operand::Register("result".to_string())),
                },
            ],
            blocks: vec![],
        };
        
        module.functions.push(callee);
        module.functions.push(caller);
        
        let result = code_generator.generate(module);
        assert!(result.is_ok(), "Function call should compile successfully");
    }

    #[test]
    fn test_memory_operations_compilation() {
        let mut code_generator = CodeGenerator::new().expect("Failed to create CodeGenerator");
        let mut module = IRModule::new();
        
        let function = IRFunction {
            name: "memory_func".to_string(),
            params: vec![],
            return_type: "int".to_string(),
            instructions: vec![
                Instruction::Alloca {
                    dest: "ptr".to_string(),
                    size: 4, // Size for int
                },
                Instruction::Store {
                    address: Operand::Register("ptr".to_string()),
                    value: Operand::Constant(42),
                },
                Instruction::Load {
                    dest: "loaded".to_string(),
                    address: Operand::Register("ptr".to_string()),
                },
                Instruction::Return {
                    value: Some(Operand::Register("loaded".to_string())),
                },
            ],
            blocks: vec![],
        };
        
        module.functions.push(function);
        
        let result = code_generator.generate(module);
        assert!(result.is_ok(), "Memory operations should compile successfully");
    }
}

#[cfg(test)]
mod jit_compiler_tests {
    use super::*;

    #[test]
    fn test_jit_compiler_creation() {
        let result = JITCompiler::new();
        assert!(result.is_ok(), "JIT compiler should be created successfully");
    }

    #[test]
    fn test_jit_compilation() {
        let mut jit_compiler = JITCompiler::new().expect("Failed to create JIT compiler");
        let ir_module = create_simple_ir_module();
        
        // Test that JIT compilation works (execution testing would require more complex setup)
        let result = jit_compiler.compile(ir_module);
        assert!(result.is_ok(), "JIT compilation should succeed");
    }

    #[test]
    fn test_jit_arithmetic_compilation() {
        let mut jit_compiler = JITCompiler::new().expect("Failed to create JIT compiler");
        let ir_module = create_arithmetic_ir_module();
        
        let result = jit_compiler.compile(ir_module);
        assert!(result.is_ok(), "JIT arithmetic compilation should succeed");
    }

    #[test]
    fn test_jit_empty_module_handling() {
        let mut jit_compiler = JITCompiler::new().expect("Failed to create JIT compiler");
        
        // Create an empty IR module
        let ir_module = IRModule::new();
        
        let result = jit_compiler.compile(ir_module);
        // Empty module should still compile successfully (just no functions)
        assert!(result.is_ok(), "JIT should handle empty module gracefully");
    }

    #[test]
    fn test_jit_multiple_functions() {
        let mut jit_compiler = JITCompiler::new().expect("Failed to create JIT compiler");
        let mut module = IRModule::new();
        
        // Add multiple simple functions
        for i in 0..3 {
            let function = IRFunction {
                name: format!("func{}", i),
                params: vec![],
                return_type: "int".to_string(),
                instructions: vec![
                    Instruction::Return {
                        value: Some(Operand::Constant(i * 10)),
                    },
                ],
                blocks: vec![],
            };
            module.functions.push(function);
        }
        
        let result = jit_compiler.compile(module);
        assert!(result.is_ok(), "JIT should compile multiple functions successfully");
    }
}
